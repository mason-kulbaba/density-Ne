
R version 3.5.2 (2018-12-20) -- "Eggshell Igloo"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> 
> #Load data
> fin<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/density-Ne/data/aster.dat.csv")
> 
> #change class of factor variables
> fin$Den<- as.factor(fin$Den)
> fin$Gen<- as.factor(fin$Gen)
> fin$plotID<- as.factor(fin$plotID)
> fin$plantID<- as.factor(fin$plantID)
> fin$familyID<- as.factor(fin$familyID)
> 
> #load aster
> library(aster)
Loading required package: trust
> 
> #set graphical model: Flower Number -> Fruit Number -> Subsampled Fruit -> Seed Number
> 
> #set vars
> vars<- c( "flw", "frt", "frt.2","seeds")
> 
> #reshape data so that all response variables are located in a single vector in a new data
> #set called "redata"
> redata <- reshape(fin, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
> 
> 
> #Designation of fitness variable
> fit <- grepl("seeds", as.character(redata$varb))
> fit<- as.numeric(fit)
> 
> redata$fit <- fit
> 
> #check
> with(redata, sort(unique(as.character(varb)[fit == 0])))
[1] "flw"   "frt"   "frt.2"
> with(redata, sort(unique(as.character(varb)[fit == 1])))
[1] "seeds"
> 
> #add a variable "root" to redata, where value is 1
> redata<- data.frame(redata, root=1)
> 
> 
> #set graph. model and family for each node
> pred<- c(0,1,2,3)
> fam<- c(1,2,2,2)
> 
> #check family 
> sapply(fam.default(), as.character)[fam]
[1] "bernoulli" "poisson"   "poisson"   "poisson"  
> 
> #run aster with only fitness
> 
> aout<- aster(resp~varb , pred, fam, varb, id, root, data=redata)
> 
> summary(aout, show.graph=T)

Call:
aster.formula(formula = resp ~ varb, pred = pred, fam = fam, 
    varvar = varb, idvar = id, root = root, data = redata)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

            Estimate Std. Error z value Pr(>|z|)    
(Intercept) -44.6476     0.5507  -81.08   <2e-16 ***
varbfrt      49.1734     0.5599   87.82   <2e-16 ***
varbfrt.2    34.2048     0.5538   61.76   <2e-16 ***
varbseeds    46.9877     0.5507   85.32   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> #add density
> aout.d<- aster(resp~varb + fit:(Den), pred, fam, varb, id, root, data=redata)
> 
> summary(aout.d, show.graph=T)

Call:
aster.formula(formula = resp ~ varb + fit:(Den), pred = pred, 
    fam = fam, varvar = varb, idvar = id, root = root, data = redata)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

              Estimate Std. Error z value Pr(>|z|)    
(Intercept) -39.755770   0.597861 -66.497   <2e-16 ***
varbfrt      44.287436   0.606131  73.066   <2e-16 ***
varbfrt.2    29.362530   0.598590  49.053   <2e-16 ***
varbseeds    42.077712   0.597597  70.412   <2e-16 ***
fit:DenH      0.041854   0.003121  13.411   <2e-16 ***
fit:DenL     -0.039658   0.004752  -8.346   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:DenM 
> 
> anova(aout, aout.d) #density is significant
Analysis of Deviance Table

Model 1: resp ~ varb
Model 2: resp ~ varb + fit:(Den)
  Model Df Model Dev Df Deviance P(>|Chi|)    
1        4    132606                          
2        6    133112  2   505.61 < 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> #add density and Ne
> aout.dg<- aster(resp~varb + fit:(Den + Gen), pred, fam, varb, id, root, data=redata)
> 
> summary(aout.dg, show.graph=T)

Call:
aster.formula(formula = resp ~ varb + fit:(Den + Gen), pred = pred, 
    fam = fam, varvar = varb, idvar = id, root = root, data = redata)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

              Estimate Std. Error z value Pr(>|z|)    
(Intercept) -38.436651   0.570184  -67.41   <2e-16 ***
varbfrt      42.971860   0.578764   74.25   <2e-16 ***
varbfrt.2    28.072418   0.570263   49.23   <2e-16 ***
varbseeds    40.775220   0.569845   71.56   <2e-16 ***
fit:DenH      0.040797   0.003083   13.23   <2e-16 ***
fit:DenL     -0.046588   0.004664   -9.99   <2e-16 ***
fit:GenLG    -0.048047   0.003018  -15.92   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:DenM 
> 
> anova(aout.d, aout.dg)#significant
Analysis of Deviance Table

Model 1: resp ~ varb + fit:(Den)
Model 2: resp ~ varb + fit:(Den + Gen)
  Model Df Model Dev Df Deviance P(>|Chi|)    
1        6    133112                          
2        7    133406  1   294.19 < 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> #add interaction between Den & Gen
> 
> aout.dg2<- aster(resp~varb + fit:(Den + Gen + Den*Gen), pred, fam, varb, id, root, data=redata)
> 
> summary(aout.dg2)

Call:
aster.formula(formula = resp ~ varb + fit:(Den + Gen + Den * 
    Gen), pred = pred, fam = fam, varvar = varb, idvar = id, 
    root = root, data = redata)

                 Estimate Std. Error z value Pr(>|z|)    
(Intercept)    -39.685580   0.573110 -69.246  < 2e-16 ***
varbfrt         44.223124   0.581733  76.020  < 2e-16 ***
varbfrt.2       29.337161   0.574020  51.108  < 2e-16 ***
varbseeds       42.019372   0.572764  73.362  < 2e-16 ***
fit:DenH         0.050631   0.003726  13.589  < 2e-16 ***
fit:DenL        -0.061064   0.005868 -10.407  < 2e-16 ***
fit:GenLG       -0.076651   0.004327 -17.716  < 2e-16 ***
fit:DenL:GenLG   0.081842   0.006936  11.799  < 2e-16 ***
fit:DenM:GenLG   0.039494   0.006678   5.914 3.34e-09 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:DenM 
> 
> anova(aout.dg, aout.dg2)# interaction is significant
Analysis of Deviance Table

Model 1: resp ~ varb + fit:(Den + Gen)
Model 2: resp ~ varb + fit:(Den + Gen + Den * Gen)
  Model Df Model Dev Df Deviance P(>|Chi|)    
1        7    133406                          
2        9    133542  2   135.58 < 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> 
> #add plot ID 
> 
> 
> aoutc<- aster(resp~varb + fit:(plotID + Den + Gen + Den*Gen), pred, fam, varb, id, root, data=redata)
> 
> summary(aoutc, show.graph=T)

Call:
aster.formula(formula = resp ~ varb + fit:(plotID + Den + Gen + 
    Den * Gen), pred = pred, fam = fam, varvar = varb, idvar = id, 
    root = root, data = redata)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

               Estimate Std. Error z value Pr(>|z|)    
(Intercept)  -37.862132   0.594544 -63.683  < 2e-16 ***
varbfrt       42.414140   0.602792  70.363  < 2e-16 ***
varbfrt.2     27.620364   0.594622  46.450  < 2e-16 ***
varbseeds     40.099155   0.596376  67.238  < 2e-16 ***
fit:plotID1    0.107193   0.010629  10.085  < 2e-16 ***
fit:plotID2    0.018053   0.012738   1.417  0.15641    
fit:plotID3   -0.055465   0.018987  -2.921  0.00349 ** 
fit:plotID4   -0.028087   0.014469  -1.941  0.05223 .  
fit:plotID5    0.007564   0.012785   0.592  0.55408    
fit:plotID6    0.027366   0.012667   2.160  0.03074 *  
fit:plotID7    0.059572   0.011864   5.021 5.13e-07 ***
fit:plotID8    0.061736   0.011796   5.233 1.66e-07 ***
fit:plotID9    0.067894   0.011607   5.849 4.94e-09 ***
fit:plotID10   0.087198   0.011071   7.876 3.38e-15 ***
fit:plotID11   0.056926   0.011947   4.765 1.89e-06 ***
fit:plotID12   0.100938   0.010755   9.385  < 2e-16 ***
fit:plotID13   0.180417   0.009807  18.398  < 2e-16 ***
fit:plotID14   0.076877   0.011345   6.776 1.23e-11 ***
fit:plotID15   0.033981   0.012566   2.704  0.00685 ** 
fit:plotID16   0.014427   0.012752   1.131  0.25793    
fit:plotID17   0.014738   0.012751   1.156  0.24777    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:plotID18 
     fit:DenL 
     fit:DenM 
     fit:GenLG 
     fit:DenL:GenLG 
     fit:DenM:GenLG 
> 
> 
> anova(aout.dg2, aoutc)# plotID significant
Analysis of Deviance Table

Model 1: resp ~ varb + fit:(Den + Gen + Den * Gen)
Model 2: resp ~ varb + fit:(plotID + Den + Gen + Den * Gen)
  Model Df Model Dev Df Deviance P(>|Chi|)    
1        9    133542                          
2       21    134616 12   1074.7 < 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> 
> ###################################################################################
> #Generate Fitness Estimates for High and Low Ne  with respect to Density Treatment#
> ###################################################################################
> 
> #First, isloate high Ne (HG) data
> 
> redataHG<- subset(redata, Gen=="HG")
> 
> redataLG<- subset(redata, Gen=="LG")
> 
> redataHG<- droplevels(redataHG)
> 
> redataLG<- droplevels(redataLG)
> 
> #with just fitness
> aoutHG<- aster(resp~varb, pred, fam, varb, id, root, data=redataHG)
> 
> #add density
> aoutHG2<- aster(resp~varb + fit:(Den), pred, fam, varb, id, root, data=redataHG)
> 
> summary(aoutHG, show.graph = T)

Call:
aster.formula(formula = resp ~ varb, pred = pred, fam = fam, 
    varvar = varb, idvar = id, root = root, data = redataHG)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

            Estimate Std. Error z value Pr(>|z|)    
(Intercept) -46.7514     0.8383  -55.77   <2e-16 ***
varbfrt      51.2764     0.8499   60.33   <2e-16 ***
varbfrt.2    35.6147     0.8417   42.31   <2e-16 ***
varbseeds    49.1697     0.8383   58.66   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> summary(aoutHG2, show.graph=T)

Call:
aster.formula(formula = resp ~ varb + fit:(Den), pred = pred, 
    fam = fam, varvar = varb, idvar = id, root = root, data = redataHG)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

              Estimate Std. Error z value Pr(>|z|)    
(Intercept) -37.702589   0.851082  -44.30   <2e-16 ***
varbfrt      42.242416   0.862010   49.01   <2e-16 ***
varbfrt.2    26.664567   0.850417   31.36   <2e-16 ***
varbseeds    40.096837   0.850770   47.13   <2e-16 ***
fit:DenH      0.048489   0.003650   13.28   <2e-16 ***
fit:DenL     -0.070015   0.006872  -10.19   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:DenM 
> 
> anova(aoutHG, aoutHG2)# density is significant
Analysis of Deviance Table

Model 1: resp ~ varb
Model 2: resp ~ varb + fit:(Den)
  Model Df Model Dev Df Deviance P(>|Chi|)    
1        4     89573                          
2        6     90187  2   614.18 < 2.2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> 
> #LG with just fitness
> aoutLG<- aster(resp~varb, pred, fam, varb, id, root, data=redataLG)
> 
> #add density
> aoutLG2<- aster(resp~varb + fit:(Den), pred, fam, varb, id, root, data=redataLG)
> 
> summary(aoutLG, show.graph = T)

Call:
aster.formula(formula = resp ~ varb, pred = pred, fam = fam, 
    varvar = varb, idvar = id, root = root, data = redataLG)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

            Estimate Std. Error z value Pr(>|z|)    
(Intercept) -42.0953     0.7497  -56.15   <2e-16 ***
varbfrt      46.6262     0.7638   61.05   <2e-16 ***
varbfrt.2    32.9264     0.7552   43.60   <2e-16 ***
varbseeds    44.2799     0.7497   59.06   <2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> summary(aoutLG2, show.graph=T)

Call:
aster.formula(formula = resp ~ varb + fit:(Den), pred = pred, 
    fam = fam, varvar = varb, idvar = id, root = root, data = redataLG)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

              Estimate Std. Error z value Pr(>|z|)    
(Intercept) -41.520615   0.776686 -53.459  < 2e-16 ***
varbfrt      46.051828   0.790274  58.273  < 2e-16 ***
varbfrt.2    32.355588   0.781521  41.401  < 2e-16 ***
varbseeds    43.704518   0.776742  56.266  < 2e-16 ***
fit:DenH      0.010151   0.005359   1.894  0.05822 .  
fit:DenL     -0.015065   0.005258  -2.865  0.00417 ** 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:DenM 
> 
> anova(aoutLG, aoutLG2)
Analysis of Deviance Table

Model 1: resp ~ varb
Model 2: resp ~ varb + fit:(Den)
  Model Df Model Dev Df Deviance P(>|Chi|)    
1        4     43589                          
2        6     43612  2   23.643 7.345e-06 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
> 
> ############################################
> #####Fitness stimates for HG Treatments#####
> ############################################
> 
> #generate MLE of saturated model mean value parameter vector: mu
> pout.HG<- predict(aoutHG, se.fit=TRUE)
> 
> pout.LG<- predict(aoutHG, se.fit=TRUE)
> 
> #make up covariate data for hypothetical
> #indivs that meet "typical" criteria:
> #Therefore, "make up" covariate data for hypothetical individuals
> #that re comparable and obtain mean values for them
> ##############
> 
> #make design matrix data.frame of indivudals for each density level (low, med., high)
> fred.hg <- data.frame( Den=levels(redataHG$Den), flw=1, frt=1,frt.2=1, seeds=1,root = 1)
> 
> fred.lg <- data.frame( Den=levels(redataLG$Den), flw=1, frt=1,frt.2=1, seeds=1,root = 1)
> 
> 
> #reshape the design matrix just as the actual data
> renewdata.hg <- reshape(fred.hg, varying = list(vars),
+                      direction = "long", timevar = "varb",
+                      times = as.factor(vars), v.names = "resp")
> 
> renewdata.lg <- reshape(fred.lg, varying = list(vars),
+                         direction = "long", timevar = "varb",
+                         times = as.factor(vars), v.names = "resp")
> 
> #make character string from "varb" of renewdata,
> #without actual values (i.e., the layers of varb in renewdata)
> layer<- gsub("[0-9]", "", as.character(renewdata.hg$varb))
> 
> 
> #add layer to renewdata
> renewdata.hg<- data.frame(renewdata.hg, layer= layer)
> 
> renewdata.lg<- data.frame(renewdata.lg, layer= layer)
> 
> #seed seed.ct in new layer col of renewdata as numeric, called fit
> fit<- as.numeric(layer=="seeds")
> 
> 
> 
> #add fit to renewdata
> renewdata.gh<- data.frame(renewdata.hg, fit = fit)
> 
> renewdata.lg<- data.frame(renewdata.lg, fit = fit)
> 
> #rerun prediction of aout, with "made up" renewdata
> pout.hg<- predict(aoutHG2, newdata= renewdata.hg, varvar= varb,
+                idvar = id, root = root, se.fit = TRUE)
> 
> pout.lg<- predict(aoutLG2, newdata= renewdata.lg, varvar= varb,
+                idvar = id, root = root, se.fit = TRUE)
> 
> 
> sapply(pout.hg, class)
      fit    se.fit  gradient    modmat 
"numeric" "numeric"  "matrix"   "array" 
> sapply(pout.lg, class)
      fit    se.fit  gradient    modmat 
"numeric" "numeric"  "matrix"   "array" 
> # lengths of fit and se.fit (12) match row number of renewdata 
> #(as should be with predict.aster)
> sapply(pout.hg, length)
     fit   se.fit gradient   modmat 
      12       12       72       72 
> sapply(pout.lg, length)
     fit   se.fit gradient   modmat 
      12       12       72       72 
> 
> #therefore, can make 12 CIs, one for each of 4 nodes of graphical model, 
> #and 3 density treatmetns (4 x 3 =12).
> 
> #Next step, combine EXPECTED Darwinian fitness with SE for three density treaments
> 
> 
> #put the parameter estimates into a matrix with individuals in rows
> #and nodes in columns
> 
> #extrac HG resutls
> nnode<- length(vars)
> sally.hg<- matrix(pout.hg$fit, ncol = nnode)
> dim(sally.hg)# makes 3 x 4 matrix: 3 densities by 4 nodes
[1] 3 4
> 
> #name the rows (by Den Treat) and columns (as nodes)
> rownames(sally.hg)<- unique(as.character(renewdata.hg$Den))
> colnames(sally.hg)<- unique(as.character(renewdata.hg$varb))
> 
> #view matrix 
> round(sally.hg, 3)
    flw    frt  frt.2   seeds
H 1.000 61.951 36.336 418.028
L 0.861 34.901  5.659  57.833
M 1.000 48.425 16.477 180.583
> 
> #now generate matrix of standard errors
> 
> nnode2<- length(vars)
> sally2<- matrix(pout.hg$se.fit, ncol = nnode)
> dim(sally2)# makes 3 x 4 matrix: 3 densities by 4 nodes
[1] 3 4
> 
> #name the rows (by Den Treat) and columns (as nodes)
> rownames(sally2)<- unique(as.character(renewdata.hg$Den))
> colnames(sally2)<- unique(as.character(renewdata.hg$varb))
> 
> #view matrix 
> round(sally2, 3)
    flw   frt frt.2  seeds
H 0.000 1.012 1.253 14.952
L 0.058 2.412 0.560  5.972
M 0.000 0.821 0.765  8.874
> 
> #combine estimates with standard errors for only final node: seeds
> ests<- sally.hg[,grepl("seeds", colnames(sally.hg))]
> se<-  sally2[,grepl("seeds", colnames(sally2))]
> 
> HG<- cbind(ests, se)# these are the fitness ests (and SE) for high Ne, across 3 densities
> 
> #now extract LG results
> 
> #extrac HG resutls
> nnode<- length(vars)
> sally.lg<- matrix(pout.lg$fit, ncol = nnode)
> dim(sally.lg)# makes 3 x 4 matrix: 3 densities by 4 nodes
[1] 3 4
> 
> #name the rows (by Den Treat) and columns (as nodes)
> rownames(sally.lg)<- unique(as.character(renewdata.lg$Den))
> colnames(sally.lg)<- unique(as.character(renewdata.lg$varb))
> 
> #view matrix 
> round(sally.lg, 3)
    flw    frt  frt.2   seeds
H 0.977 45.194 13.701 122.917
L 0.735 31.994  7.757  67.861
M 0.927 41.784 11.570 102.750
> 
> #now generate matrix of standard errors
> 
> nnode2<- length(vars)
> sally.lg2<- matrix(pout.lg$se.fit, ncol = nnode)
> dim(sally.lg2)# makes 3 x 4 matrix: 3 densities by 4 nodes
[1] 3 4
> 
> #name the rows (by Den Treat) and columns (as nodes)
> rownames(sally.lg2)<- unique(as.character(renewdata.lg$Den))
> colnames(sally.lg2)<- unique(as.character(renewdata.lg$varb))
> 
> #view matrix 
> round(sally.lg2, 3)
    flw   frt frt.2 seeds
H 0.014 1.188 0.772 7.298
L 0.068 3.086 0.924 8.279
M 0.033 1.840 0.825 7.632
> 
> #combine estimates with standard errors for only final node: seeds
> ests<- sally.lg[,grepl("seeds", colnames(sally.lg))]
> se<-  sally.lg2[,grepl("seeds", colnames(sally.lg2))]
> 
> LG<- cbind(ests, se)# these are the fitness ests (and SE) for high Ne, across 3 densities
> 
> #fitness and standard errors for HG and LG treatments (across densities)
> HG
       ests        se
H 418.02778 14.951711
L  57.83334  5.971818
M 180.58333  8.874330
> 
> LG
      ests       se
H 122.9167 7.298401
L  67.8611 8.278818
M 102.7500 7.631958
> 
> 
> 
> ##################################################################################
> #Calculate mean seed set for each treat x Ne treat to "relativize" female fitness#
> ##################################################################################
> 
> #calculate mean seed set for each plot
> 
> aggregate(fin$seeds, by=list(fin$plotID), mean)
   Group.1          x
1        1  250.00000
2        2   68.91667
3        3   11.08333
4        4   25.25000
5        5   57.75000
6        6   79.33333
7        7  123.75000
8        8  127.50000
9        9  138.91667
10      10  183.58333
11      11  119.33333
12      12  226.41667
13      13 1012.75000
14      14  157.83333
15      15   87.16667
16      16   65.00000
17      17   65.33333
18      18   50.00000
> 
> 
> 
> 
> ###############################################################################################
> ###############################################################################################
> #To compliment familyID estimates of fit via siring success, produce familyID estimates of 
> #fitness via seed set, on L, M, H density for High Ne
> ###############################################################################################
> ###############################################################################################
> 
> #Load data
> fin<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/density-Ne/data/aster.sire.dat.csv")
> 
> #sum of number of seeds that we successfully assigned paternity to, per density treatment
> aggregate(fin$sires, by=list(fin$Den), sum)
  Group.1   x
1       H 175
2       L 166
3       M 172
> 
> #change class of factor variables
> fin$Den<- as.factor(fin$Den)
> fin$Gen<- as.factor(fin$Gen)
> fin$plotID<- as.factor(fin$plotID)
> fin$plantID<- as.factor(fin$plantID)
> fin$familyID<- as.factor(fin$familyID)
> 
> #load aster
> library(aster)
> 
> #set vars
> vars<- c( "flw", "frt", "frt.2","seeds")
> 
> 
> datH<- subset(fin, Den=="H")
> datH$familyID<- droplevels(datH$familyID)
> datM<- subset(fin, Den=="M")
> datM$familyID<- droplevels(datM$familyID)
> datL<- subset(fin, Den=="L")
> datL$familyID<- droplevels(datL$familyID)
> 
> 
> #reshape data so that all response variables are located in a single vector in a new data
> #set called "redata"
> redataH <- reshape(datH, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
> redataM <- reshape(datM, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
> redataL <- reshape(datL, varying = list(vars), direction = "long",timevar = "varb", times = as.factor(vars), v.names = "resp")
> 
> 
> #Designation of fitness variable
> fit <- grepl("seeds", as.character(redataH$varb))
> fit<- as.numeric(fit)
> redataH$fit <- fit
> 
> redataM$fit <- fit
> 
> redataL$fit <- fit
> 
> #check
> with(redataH, sort(unique(as.character(varb)[fit == 0])))
[1] "flw"   "frt"   "frt.2"
> with(redataH, sort(unique(as.character(varb)[fit == 1])))
[1] "seeds"
> 
> with(redataM, sort(unique(as.character(varb)[fit == 0])))
[1] "flw"   "frt"   "frt.2"
> with(redataM, sort(unique(as.character(varb)[fit == 1])))
[1] "seeds"
> 
> with(redataL, sort(unique(as.character(varb)[fit == 0])))
[1] "flw"   "frt"   "frt.2"
> with(redataL, sort(unique(as.character(varb)[fit == 1])))
[1] "seeds"
> 
> #add a variable "root" to redata, where value is 1
> redataH<- data.frame(redataH, root=2)
> redataM<- data.frame(redataM, root=2)
> redataL<- data.frame(redataL, root=2)
> 
> #set graph. model and family for each node
> pred<- c(0,1,2,3)
> fam<- c(1,2,2,2)
> 
> 
> #aster analyses for three density treatments
> aoutH<- aster(resp~varb + fit:(familyID), pred, fam, varb, id, root, data=redataH)
> summary(aoutH, show.graph = T)

Call:
aster.formula(formula = resp ~ varb + fit:(familyID), pred = pred, 
    fam = fam, varvar = varb, idvar = id, root = root, data = redataH)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

                 Estimate Std. Error z value Pr(>|z|)    
(Intercept)    -36.086858   1.627818 -22.169  < 2e-16 ***
varbfrt         40.633965   1.643658  24.722  < 2e-16 ***
varbfrt.2       24.552921   1.623894  15.120  < 2e-16 ***
varbseeds       38.436899   1.632504  23.545  < 2e-16 ***
fit:familyID1    0.069576   0.021249   3.274  0.00106 ** 
fit:familyID2    0.153190   0.018685   8.199 2.43e-16 ***
fit:familyID3    0.119853   0.020460   5.858 4.69e-09 ***
fit:familyID4   -0.024099   0.033573  -0.718  0.47287    
fit:familyID6   -0.007988   0.030665  -0.260  0.79448    
fit:familyID7    0.138946   0.019048   7.295 2.99e-13 ***
fit:familyID8    0.180643   0.018792   9.613  < 2e-16 ***
fit:familyID9    0.113480   0.019597   5.791 7.01e-09 ***
fit:familyID11   0.154918   0.018671   8.297  < 2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:familyID14 
> 
> aoutM<- aster(resp~varb + fit:(familyID), pred, fam, varb, id, root, data=redataM)
> summary(aoutM, show.graph = T)

Call:
aster.formula(formula = resp ~ varb + fit:(familyID), pred = pred, 
    fam = fam, varvar = varb, idvar = id, root = root, data = redataM)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

                Estimate Std. Error z value Pr(>|z|)    
(Intercept)    -46.43896    2.02107 -22.977  < 2e-16 ***
varbfrt         51.25262    2.03479  25.188  < 2e-16 ***
varbfrt.2       36.53140    2.01786  18.104  < 2e-16 ***
varbseeds       48.50804    2.05645  23.588  < 2e-16 ***
fit:familyID1    0.26137    0.06701   3.901  9.6e-05 ***
fit:familyID2    0.17115    0.06764   2.530 0.011403 *  
fit:familyID4    0.09941    0.07018   1.416 0.156645    
fit:familyID6    0.13194    0.07065   1.868 0.061821 .  
fit:familyID7    0.12400    0.06847   1.811 0.070133 .  
fit:familyID9    0.16082    0.06825   2.356 0.018452 *  
fit:familyID11   0.21592    0.06723   3.212 0.001320 ** 
fit:familyID14   0.22927    0.06731   3.406 0.000659 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:familyID15 
> 
> aoutL<- aster(resp~varb + fit:(familyID), pred, fam, varb, id, root, data=redataL)
> summary(aoutL, show.graph = T)

Call:
aster.formula(formula = resp ~ varb + fit:(familyID), pred = pred, 
    fam = fam, varvar = varb, idvar = id, root = root, data = redataL)


Graphical Model:
 variable predecessor family   
 flw      root        bernoulli
 frt      flw         poisson  
 frt.2    frt         poisson  
 seeds    frt.2       poisson  

                 Estimate Std. Error z value Pr(>|z|)    
(Intercept)    -25.517173   1.105432 -23.083  < 2e-16 ***
varbfrt         29.740008   1.133509  26.237  < 2e-16 ***
varbfrt.2       14.839584   1.121753  13.229  < 2e-16 ***
varbseeds       27.756878   1.109365  25.020  < 2e-16 ***
fit:familyID1    0.043765   0.027776   1.576    0.115    
fit:familyID2    0.106163   0.025622   4.143 3.42e-05 ***
fit:familyID4   -0.003372   0.044194  -0.076    0.939    
fit:familyID6    0.015868   0.039996   0.397    0.692    
fit:familyID7    0.143954   0.025101   5.735 9.75e-09 ***
fit:familyID9    0.028787   0.031055   0.927    0.354    
fit:familyID11   0.006698   0.029933   0.224    0.823    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Original predictor variables dropped (aliased)
     fit:familyID14 
> 
> #generate estimates: High -> Med -> Low
> 
> ###########################
> ####HIGH DENSITY
> ##########################
> 
> 
> #generate MLE of saturated model mean value parameter vector: mu
> pout<- predict.aster(aoutH, se.fit=TRUE)
> 
> 
> #make data.frame of indivudals for each block (1-8)
> fred <- data.frame(familyID=levels(redataH$familyID), flw=1, frt=1, frt.2=1, seeds=1,root = 2)
> 
> #reshape the "made up data" just as the actual data
> renewdata <- reshape(fred, varying = list(vars),
+                      direction = "long", timevar = "varb",
+                      times = as.factor(vars), v.names = "resp")
> 
> #make character string from "varb" of renewdata,
> #without actual values (e.g., the layers of varb in renewdata)
> layer<- gsub("[0-9]", "", as.character(renewdata$varb))
> 
> #add layer to renewdata
> renewdata<- data.frame(renewdata, layer= layer)
> 
> #seed seed.ct in new layer col of renewdata as numeric, called fit
> fit<- as.numeric(layer=="seeds")
> 
> #add fit to renewdata
> renewdata<- data.frame(renewdata, fit = fit)
> 
> #rerun prediction of aout, with "made up" renewdata
> pout<- predict(aoutH, newdata= renewdata, varvar= varb,
+                idvar = id, root = root, se.fit = TRUE)
> 
> sapply(pout, class)
      fit    se.fit  gradient    modmat 
"numeric" "numeric"  "matrix"   "array" 
> # lengths of fit and se.fit (32)match lengths of renewdata 
> #(as should be with predict.aster)
> sapply(pout, length)
     fit   se.fit gradient   modmat 
      40       40      520      520 
> 
> #put the parameter estimates into a matrix with individuals in rows
> #and nodes along columns
> nnode<- length(vars)
> sally<- matrix(pout$fit, ncol = nnode)
> dim(sally)# makes 8 x 4 matrix: 8 indiv by 4 nodes
[1] 10  4
> 
> #name the rows (by Den Treat) and columns (as nodes)
> rownames(sally)<- unique(as.character(renewdata$familyID))
> colnames(sally)<- unique(as.character(renewdata$varb))
> 
> #view matrix 
> round(sally, 3)
     flw     frt   frt.2    seeds
1  2.000  91.349  25.086  282.000
2  2.000 144.347 105.657 1291.333
3  2.000 113.357  55.578  657.000
4  1.570  60.269   6.057   62.000
6  1.762  68.853   8.171   85.000
7  2.000 128.513  79.135  953.500
8  2.000 194.184 199.728 2509.000
9  2.000 109.407  49.761  584.500
11 2.000 146.621 109.613 1342.000
14 1.834  72.448   9.346   98.000
> 
> #use just totalseeds as predicted (expected) fitneses
> herman<- sally[,grepl("seeds", colnames(sally))]
> 
> #these are expected fitness for each block of Grey Cloud Dunes
> herman #median = 0.8888
       1        2        3        4        6        7        8        9 
 282.000 1291.333  657.000   62.000   85.000  953.500 2509.000  584.500 
      11       14 
1342.000   98.000 
> 
> #Generate Standard Errors for these estimates
> 
> nFam<- nrow(fred)
> nnode<- length(vars)
> amat<- array(0, c(nFam, nnode, nFam))
> dim(amat)# makes an 8 x 4 x 8 matrix
[1] 10  4 10
> 
> 
> foo<- grepl("seeds", vars)
> for(k in 1:nFam)
+   amat[k, foo, k]<- 1
> 
> #use aout object, with renewdata, and amat format
> pout.amat<- predict(aoutH, newdata= renewdata, varvar= varb,
+                     idvar= id, root = root, se.fit=TRUE, amat = amat)
> 
> #pout.amat$fit should be the same as file "herman"
> herman
       1        2        3        4        6        7        8        9 
 282.000 1291.333  657.000   62.000   85.000  953.500 2509.000  584.500 
      11       14 
1342.000   98.000 
> pout.amat$fit #they are the same.  Good.
 [1]  282.000 1291.333  657.000   62.000   85.000  953.500 2509.000  584.500
 [9] 1342.000   98.000
> 
> #combine std.err with estimates, and then round
> #to three decimal places
> foo<- cbind(pout.amat$fit, pout.amat$se.fit)
> rownames(foo)<- as.character(fred$Den)
> colnames(foo)<- c("High Den Fitness", "SE")
> round(foo, 3) 
      High Den Fitness      SE
 [1,]          282.000  46.530
 [2,]         1291.333  97.684
 [3,]          657.000 110.596
 [4,]           62.000  35.868
 [5,]           85.000  39.537
 [6,]          953.500  98.785
 [7,]         2509.000 257.770
 [8,]          584.500  72.707
 [9,]         1342.000 100.092
[10,]           98.000  29.081
> H_estimates<- foo
> 
> famsH<- unique(levels(redataH$familyID))
> row.names(H_estimates)<- famsH
> H_estimates
   High Den Fitness        SE
1           282.000  46.52968
2          1291.333  97.68353
3           657.000 110.59556
4            62.000  35.86771
6            85.000  39.53685
7           953.500  98.78455
8          2509.000 257.77015
9           584.500  72.70743
11         1342.000 100.09213
14           98.000  29.08132
> 
> ########################################
> #####MEDIUM DENSITY
> #######################################
> 
> #generate MLE of saturated model mean value parameter vector: mu
> pout<- predict.aster(aoutM, se.fit=TRUE)
> 
> 
> #make data.frame of indivudals for each block (1-8)
> fred <- data.frame(familyID=levels(redataM$familyID), flw=1, frt=1, frt.2=1, seeds=1,root = 2)
> 
> #reshape the "made up data" just as the actual data
> renewdata <- reshape(fred, varying = list(vars),
+                      direction = "long", timevar = "varb",
+                      times = as.factor(vars), v.names = "resp")
> 
> #make character string from "varb" of renewdata,
> #without actual values (e.g., the layers of varb in renewdata)
> layer<- gsub("[0-9]", "", as.character(renewdata$varb))
> 
> #add layer to renewdata
> renewdata<- data.frame(renewdata, layer= layer)
> 
> #seed seed.ct in new layer col of renewdata as numeric, called fit
> fit<- as.numeric(layer=="seeds")
> 
> #add fit to renewdata
> renewdata<- data.frame(renewdata, fit = fit)
> 
> #rerun prediction of aout, with "made up" renewdata
> pout<- predict(aoutM, newdata= renewdata, varvar= varb,
+                idvar = id, root = root, se.fit = TRUE)
> 
> sapply(pout, class)
      fit    se.fit  gradient    modmat 
"numeric" "numeric"  "matrix"   "array" 
> # lengths of fit and se.fit (32)match lengths of renewdata 
> #(as should be with predict.aster)
> sapply(pout, length)
     fit   se.fit gradient   modmat 
      36       36      432      432 
> 
> #put the parameter estimates into a matrix with individuals in rows
> #and nodes along columns
> nnode<- length(vars)
> sally<- matrix(pout$fit, ncol = nnode)
> dim(sally)# makes 8 x 4 matrix: 8 indiv by 4 nodes
[1] 9 4
> 
> #name the rows (by Den Treat) and columns (as nodes)
> rownames(sally)<- unique(as.character(renewdata$familyID))
> colnames(sally)<- unique(as.character(renewdata$varb))
> 
> #view matrix 
> round(sally, 3)
     flw     frt  frt.2   seeds
1  2.000 154.794 82.858 852.000
2  2.000 112.973 24.906 234.000
4  1.936  98.406 11.321  99.000
6  1.991 105.206 16.161 146.000
7  1.984 103.752 14.839 133.000
9  1.999 110.676 22.153 206.000
11 2.000 127.203 43.118 423.667
14 2.000 133.439 51.618 514.000
15 1.107  52.743  2.652  21.000
> 
> #use just totalseeds as predicted (expected) fitneses
> herman<- sally[,grepl("seeds", colnames(sally))]
> 
> #these are expected fitness for each block of Grey Cloud Dunes
> herman #median = 0.8888
       1        2        4        6        7        9       11       14 
852.0000 234.0000  99.0000 146.0000 133.0000 206.0000 423.6667 514.0000 
      15 
 21.0000 
> 
> #Generate Standard Errors for these estimates
> 
> nFam<- nrow(fred)
> nnode<- length(vars)
> amat<- array(0, c(nFam, nnode, nFam))
> dim(amat)# makes an 8 x 4 x 8 matrix
[1] 9 4 9
> 
> 
> foo<- grepl("seeds", vars)
> for(k in 1:nFam)
+   amat[k, foo, k]<- 1
> 
> #use aout object, with renewdata, and amat format
> pout.amat<- predict(aoutM, newdata= renewdata, varvar= varb,
+                     idvar= id, root = root, se.fit=TRUE, amat = amat)
> 
> #pout.amat$fit should be the same as file "herman"
> herman
       1        2        4        6        7        9       11       14 
852.0000 234.0000  99.0000 146.0000 133.0000 206.0000 423.6667 514.0000 
      15 
 21.0000 
> pout.amat$fit #they are the same.  Good.
[1] 852.0000 234.0000  99.0000 146.0000 133.0000 206.0000 423.6667 514.0000
[9]  21.0000
> 
> #combine std.err with estimates, and then round
> #to three decimal places
> foo<- cbind(pout.amat$fit, pout.amat$se.fit)
> rownames(foo)<- as.character(fred$Den)
> colnames(foo)<- c("Med Den Fitness", "SE")
> round(foo, 3) 
      Med Den Fitness     SE
 [1,]         852.000 69.047
 [2,]         234.000 31.201
 [3,]          99.000 35.036
 [4,]         146.000 41.421
 [5,]         133.000 27.974
 [6,]         206.000 35.445
 [7,]         423.667 44.712
 [8,]         514.000 61.694
 [9,]          21.000 19.328
> M_estimates<- foo
> 
> famsM<- unique(levels(redataM$familyID))
> row.names(M_estimates)<- famsM
> M_estimates
   Med Den Fitness       SE
1         852.0000 69.04651
2         234.0000 31.20058
4          99.0000 35.03631
6         146.0000 41.42072
7         133.0000 27.97436
9         206.0000 35.44516
11        423.6667 44.71236
14        514.0000 61.69364
15         21.0000 19.32803
> 
> ########################################
> #####LOW DENSITY
> #######################################
> 
> #generate MLE of saturated model mean value parameter vector: mu
> pout<- predict.aster(aoutL, se.fit=TRUE)
> 
> 
> #make data.frame of indivudals for each block (1-8)
> fred <- data.frame(familyID=levels(redataL$familyID), flw=1, frt=1, frt.2=1, seeds=1,root = 2)
> 
> #reshape the "made up data" just as the actual data
> renewdata <- reshape(fred, varying = list(vars),
+                      direction = "long", timevar = "varb",
+                      times = as.factor(vars), v.names = "resp")
> 
> #make character string from "varb" of renewdata,
> #without actual values (e.g., the layers of varb in renewdata)
> layer<- gsub("[0-9]", "", as.character(renewdata$varb))
> 
> #add layer to renewdata
> renewdata<- data.frame(renewdata, layer= layer)
> 
> #seed seed.ct in new layer col of renewdata as numeric, called fit
> fit<- as.numeric(layer=="seeds")
> 
> #add fit to renewdata
> renewdata<- data.frame(renewdata, fit = fit)
> 
> #rerun prediction of aout, with "made up" renewdata
> pout<- predict(aoutM, newdata= renewdata, varvar= varb,
+                idvar = id, root = root, se.fit = TRUE)
> 
> sapply(pout, class)
      fit    se.fit  gradient    modmat 
"numeric" "numeric"  "matrix"   "array" 
> # lengths of fit and se.fit (32)match lengths of renewdata 
> #(as should be with predict.aster)
> sapply(pout, length)
     fit   se.fit gradient   modmat 
      32       32      384      384 
> 
> #put the parameter estimates into a matrix with individuals in rows
> #and nodes along columns
> nnode<- length(vars)
> sally<- matrix(pout$fit, ncol = nnode)
> dim(sally)# makes 8 x 4 matrix: 8 indiv by 4 nodes
[1] 8 4
> 
> #name the rows (by Den Treat) and columns (as nodes)
> rownames(sally)<- unique(as.character(renewdata$familyID))
> colnames(sally)<- unique(as.character(renewdata$varb))
> 
> #view matrix 
> round(sally, 3)
     flw     frt  frt.2   seeds
1  2.000 154.794 82.858 852.000
2  2.000 112.973 24.906 234.000
4  1.936  98.406 11.321  99.000
6  1.991 105.206 16.161 146.000
7  1.984 103.752 14.839 133.000
9  1.999 110.676 22.153 206.000
11 2.000 127.203 43.118 423.667
14 2.000 133.439 51.618 514.000
> 
> #use just totalseeds as predicted (expected) fitneses
> herman<- sally[,grepl("seeds", colnames(sally))]
> 
> #these are expected fitness for each block of Grey Cloud Dunes
> herman #median = 0.8888
       1        2        4        6        7        9       11       14 
852.0000 234.0000  99.0000 146.0000 133.0000 206.0000 423.6667 514.0000 
> 
> #Generate Standard Errors for these estimates
> 
> nFam<- nrow(fred)
> nnode<- length(vars)
> amat<- array(0, c(nFam, nnode, nFam))
> dim(amat)# makes an 8 x 4 x 8 matrix
[1] 8 4 8
> 
> 
> foo<- grepl("seeds", vars)
> for(k in 1:nFam)
+   amat[k, foo, k]<- 1
> 
> #use aout object, with renewdata, and amat format
> pout.amat<- predict(aoutL, newdata= renewdata, varvar= varb,
+                     idvar= id, root = root, se.fit=TRUE, amat = amat)
> 
> #pout.amat$fit should be the same as file "herman"
> herman
       1        2        4        6        7        9       11       14 
852.0000 234.0000  99.0000 146.0000 133.0000 206.0000 423.6667 514.0000 
> pout.amat$fit #they are the same.  Good.
[1]  83.66667 203.66667  39.00000  54.00000 365.50000  66.50000  46.33333
[8]  41.33333
> 
> #combine std.err with estimates, and then round
> #to three decimal places
> foo<- cbind(pout.amat$fit, pout.amat$se.fit)
> rownames(foo)<- as.character(fred$Den)
> colnames(foo)<- c("Low Den Fitness", "SE")
> round(foo, 3) 
     Low Den Fitness     SE
[1,]          83.667 20.403
[2,]         203.667 31.447
[3,]          39.000 25.965
[4,]          54.000 29.824
[5,]         365.500 55.011
[6,]          66.500 22.886
[7,]          46.333 16.162
[8,]          41.333 15.383
> L_estimates<- foo
> 
> famsL<- unique(levels(redataL$familyID))
> row.names(L_estimates)<- famsL
> L_estimates
   Low Den Fitness       SE
1         83.66667 20.40337
2        203.66667 31.44708
4         39.00000 25.96483
6         54.00000 29.82351
7        365.50000 55.01150
9         66.50000 22.88594
11        46.33333 16.16179
14        41.33333 15.38330
> 
> 
> ########################################
> # these are male fitness (seeds sired) and standard error for HG treatment
> # across three density treatmetns
> 
> #make rownames first column and combine all estimates
> library(data.table)
> 
> L_estimates<- as.data.frame(L_estimates)
> M_estimates<- as.data.frame(M_estimates)
> H_estimates<- as.data.frame(H_estimates)
> 
> setDT(L_estimates, keep.rownames = TRUE)[]
   rn Low Den Fitness       SE
1:  1        83.66667 20.40337
2:  2       203.66667 31.44708
3:  4        39.00000 25.96483
4:  6        54.00000 29.82351
5:  7       365.50000 55.01150
6:  9        66.50000 22.88594
7: 11        46.33333 16.16179
8: 14        41.33333 15.38330
> setDT(M_estimates, keep.rownames = TRUE)[]
   rn Med Den Fitness       SE
1:  1        852.0000 69.04651
2:  2        234.0000 31.20058
3:  4         99.0000 35.03631
4:  6        146.0000 41.42072
5:  7        133.0000 27.97436
6:  9        206.0000 35.44516
7: 11        423.6667 44.71236
8: 14        514.0000 61.69364
9: 15         21.0000 19.32803
> setDT(H_estimates, keep.rownames = TRUE)[]
    rn High Den Fitness        SE
 1:  1          282.000  46.52968
 2:  2         1291.333  97.68353
 3:  3          657.000 110.59556
 4:  4           62.000  35.86771
 5:  6           85.000  39.53685
 6:  7          953.500  98.78455
 7:  8         2509.000 257.77015
 8:  9          584.500  72.70743
 9: 11         1342.000 100.09213
10: 14           98.000  29.08132
> 
> #write.table(L_estimates, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/density/Results/L_fem_est.csv", sep=",", row.names = F, quote = F)
> #write.table(M_estimates, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/density/Results/M_fem_est.csv", sep=",", row.names = F, quote = F)
> #write.table(H_estimates, file="C:/Users/Mason Kulbaba/Dropbox/Rscripts/density/Results/H_fem_ests.csv", sep=",", row.names = F, quote = F)
> 
> 
> #####################################################
> #Biomass Analysis
> #####################################################
> 
> #reload data
> fin<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/density-Ne/data/aster.dat.csv")
> 
> library(emmeans)
> 
> #high and low Ne data
> 
> hi<- subset(fin, Gen=="HG")
> lo<- subset(fin, Gen=="LG")
> 
> #function for standard error
> 
> stderr<- function(x) sd(x)/sqrt(length(x))
> 
> #High Ne
> #Above ground biomass
> aggregate(hi$mass.a, by=list(hi$Den), mean)
  Group.1        x
1       H 12.65000
2       L  4.20000
3       M 15.12778
> aggregate(hi$mass.a, by=list(hi$Den), stderr)
  Group.1        x
1       H 2.435705
2       L 1.195700
3       M 3.220772
> 
> #Below ground biomass
> aggregate(hi$mass.b, by=list(hi$Den), mean)
  Group.1         x
1       H 1.5922500
2       L 0.6319444
3       M 1.6233611
> aggregate(hi$mass.b, by=list(hi$Den), stderr)
  Group.1         x
1       H 0.3081703
2       L 0.1579752
3       M 0.3654846
> 
> #Low Ne
> #Above ground biomass
> aggregate(lo$mass.a, by=list(lo$Den), mean)
  Group.1        x
1       H 9.377778
2       L 2.750000
3       M 6.388889
> aggregate(lo$mass.a, by=list(lo$Den), stderr)
  Group.1         x
1       H 2.7333975
2       L 0.5085694
3       M 0.8996541
> 
> #Below ground biomass
> aggregate(lo$mass.b, by=list(lo$Den), mean)
  Group.1        x
1       H 1.426111
2       L 0.934500
3       M 1.361472
> aggregate(lo$mass.b, by=list(lo$Den), stderr)
  Group.1         x
1       H 0.2243047
2       L 0.3218768
3       M 0.2908803
> 
> #total model - above ground biomass
> 
> #log transform biomass
> 
> tot<- lm(log(mass.a)~ Den + Gen, data=fin)
> 
> summary(tot)

Call:
lm(formula = log(mass.a) ~ Den + Gen, data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-3.7465 -1.3199  0.2282  1.4551  3.3212 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   1.4439     0.2406   6.001  8.4e-09 ***
DenL         -1.0499     0.2947  -3.563 0.000454 ***
DenM         -0.1893     0.2947  -0.642 0.521248    
GenLG        -0.3201     0.2406  -1.330 0.184831    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.768 on 212 degrees of freedom
Multiple R-squared:  0.07095,	Adjusted R-squared:  0.05781 
F-statistic: 5.397 on 3 and 212 DF,  p-value: 0.001345

> 
> #generate LS means for hi genetic diversity
> ha.lm<- lm(log(mass.a) ~ factor(Den), data=hi)
> 
> summary(ha.lm)

Call:
lm(formula = log(mass.a) ~ factor(Den), data = hi)

Residuals:
    Min      1Q  Median      3Q     Max 
-4.0503 -1.4294  0.0424  1.4444  3.4042 

Coefficients:
             Estimate Std. Error t value Pr(>|t|)    
(Intercept)    1.7477     0.3052   5.727 9.82e-08 ***
factor(Den)L  -1.5223     0.4316  -3.527 0.000624 ***
factor(Den)M  -0.6285     0.4316  -1.456 0.148336    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.831 on 105 degrees of freedom
Multiple R-squared:  0.1069,	Adjusted R-squared:  0.08988 
F-statistic: 6.283 on 2 and 105 DF,  p-value: 0.002645

> 
> 
> lsmeans(ha.lm, specs="Den", type="response")
 Den response    SE  df lower.CL upper.CL
 H       5.74 1.752 105    3.135    10.52
 L       1.25 0.382 105    0.684     2.29
 M       3.06 0.935 105    1.672     5.61

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> #below
> ha.lmb<- lm(log(mass.b) ~ factor(Den), data=hi)
> summary(ha.lmb)

Call:
lm(formula = log(mass.b) ~ factor(Den), data = hi)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.4042 -1.4036  0.2137  1.8502  3.5887 

Coefficients:
             Estimate Std. Error t value Pr(>|t|)   
(Intercept)   -0.5036     0.3572  -1.410  0.16157   
factor(Den)L  -1.6988     0.5052  -3.363  0.00108 **
factor(Den)M  -0.5273     0.5052  -1.044  0.29901   
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 2.143 on 105 degrees of freedom
Multiple R-squared:  0.1014,	Adjusted R-squared:  0.08431 
F-statistic: 5.926 on 2 and 105 DF,  p-value: 0.003645

> 
> lsmeans(ha.lm, specs="Den", type="response")
 Den response    SE  df lower.CL upper.CL
 H       5.74 1.752 105    3.135    10.52
 L       1.25 0.382 105    0.684     2.29
 M       3.06 0.935 105    1.672     5.61

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> 
> #produce ls means on response scale
> emmeans(ha.lm, "Den", type='response')
 Den response    SE  df lower.CL upper.CL
 H       5.74 1.752 105    3.135    10.52
 L       1.25 0.382 105    0.684     2.29
 M       3.06 0.935 105    1.672     5.61

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> pairs(emmeans(ha.lm, "Den", type='response'))
 contrast ratio    SE  df t.ratio p.value
 H / L    4.583 1.978 105  3.527  0.0018 
 H / M    1.875 0.809 105  1.456  0.3162 
 L / M    0.409 0.177 105 -2.071  0.1009 

P value adjustment: tukey method for comparing a family of 3 estimates 
Tests are performed on the log scale 
> test(emmeans(ha.lm, "Den", type='response'))
 Den response    SE  df t.ratio p.value
 H       5.74 1.752 105 5.727   <.0001 
 L       1.25 0.382 105 0.739   0.4617 
 M       3.06 0.935 105 3.668   0.0004 

Tests are performed on the log scale 
> 
> emmeans(ha.lmb, "Den", type='response')
 Den response     SE  df lower.CL upper.CL
 H      0.604 0.2159 105   0.2976    1.227
 L      0.111 0.0395 105   0.0544    0.224
 M      0.357 0.1274 105   0.1757    0.724

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> pairs(emmeans(ha.lmb, "Den", type='response'))
 contrast ratio    SE  df t.ratio p.value
 H / L     5.47 2.762 105  3.363  0.0031 
 H / M     1.69 0.856 105  1.044  0.5511 
 L / M     0.31 0.157 105 -2.319  0.0575 

P value adjustment: tukey method for comparing a family of 3 estimates 
Tests are performed on the log scale 
> test(emmeans(ha.lmb, "Den", type='response'))
 Den response     SE  df t.ratio p.value
 H      0.604 0.2159 105 -1.410  0.1616 
 L      0.111 0.0395 105 -6.166  <.0001 
 M      0.357 0.1274 105 -2.886  0.0047 

Tests are performed on the log scale 
> 
> ####################
> #generate LS means for lo genetic diversity
> 
> lo.lm<- lm(log(mass.b) ~ factor(Den), data=lo)
> summary(lo.lm)

Call:
lm(formula = log(mass.b) ~ factor(Den), data = lo)

Residuals:
   Min     1Q Median     3Q    Max 
-5.988 -1.383  0.702  1.650  5.196 

Coefficients:
             Estimate Std. Error t value Pr(>|t|)    
(Intercept)   -0.5429     0.4202  -1.292    0.199    
factor(Den)L  -2.4668     0.5943  -4.151 6.76e-05 ***
factor(Den)M  -0.3772     0.5943  -0.635    0.527    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 2.521 on 105 degrees of freedom
Multiple R-squared:   0.16,	Adjusted R-squared:  0.144 
F-statistic: 9.998 on 2 and 105 DF,  p-value: 0.000106

> 
> 
> #produce ls means on response scale
> emmeans(lo.lm, "Den", type="response")
 Den response     SE  df lower.CL upper.CL
 H     0.5810 0.2442 105   0.2525    1.337
 L     0.0493 0.0207 105   0.0214    0.113
 M     0.3985 0.1675 105   0.1732    0.917

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> #contrasts
> pairs(emmeans(lo.lm, "Den", type="response"))
 contrast  ratio     SE  df t.ratio p.value
 H / L    11.784 7.0036 105  4.151  0.0002 
 H / M     1.458 0.8666 105  0.635  0.8014 
 L / M     0.124 0.0735 105 -3.516  0.0019 

P value adjustment: tukey method for comparing a family of 3 estimates 
Tests are performed on the log scale 
> test(emmeans(lo.lm, "Den", type="response"))
 Den response     SE  df t.ratio p.value
 H     0.5810 0.2442 105 -1.292  0.1992 
 L     0.0493 0.0207 105 -7.162  <.0001 
 M     0.3985 0.1675 105 -2.189  0.0308 

Tests are performed on the log scale 
> 
> #below ground
> 
> lo.lmb<- lm(log(mass.b) ~ factor(Den), data=hi)
> summary(lo.lmb)

Call:
lm(formula = log(mass.b) ~ factor(Den), data = hi)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.4042 -1.4036  0.2137  1.8502  3.5887 

Coefficients:
             Estimate Std. Error t value Pr(>|t|)   
(Intercept)   -0.5036     0.3572  -1.410  0.16157   
factor(Den)L  -1.6988     0.5052  -3.363  0.00108 **
factor(Den)M  -0.5273     0.5052  -1.044  0.29901   
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 2.143 on 105 degrees of freedom
Multiple R-squared:  0.1014,	Adjusted R-squared:  0.08431 
F-statistic: 5.926 on 2 and 105 DF,  p-value: 0.003645

> 
> #produce ls means on response scale
> emmeans(lo.lmb, "Den", type="response")
 Den response     SE  df lower.CL upper.CL
 H      0.604 0.2159 105   0.2976    1.227
 L      0.111 0.0395 105   0.0544    0.224
 M      0.357 0.1274 105   0.1757    0.724

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> #contrasts
> pairs(emmeans(lo.lmb, "Den", type="response"))
 contrast ratio    SE  df t.ratio p.value
 H / L     5.47 2.762 105  3.363  0.0031 
 H / M     1.69 0.856 105  1.044  0.5511 
 L / M     0.31 0.157 105 -2.319  0.0575 

P value adjustment: tukey method for comparing a family of 3 estimates 
Tests are performed on the log scale 
> test(emmeans(lo.lmb, "Den", type="response"))
 Den response     SE  df t.ratio p.value
 H      0.604 0.2159 105 -1.410  0.1616 
 L      0.111 0.0395 105 -6.166  <.0001 
 M      0.357 0.1274 105 -2.886  0.0047 

Tests are performed on the log scale 
> 
> ##############################################################
> #above ground biomass
> 
> f.lm<- lm(log(mass.a) ~ (Den) , data=fin)
> 
> f.lm2<- lm(log(mass.a) ~ (Den + Gen) , data=fin)
> 
> f.lm3<- lm(log(mass.a) ~ (Den + Gen + Den*Gen) , data=fin)
> 
> anova(f.lm, f.lm2, f.lm3)
Analysis of Variance Table

Model 1: log(mass.a) ~ (Den)
Model 2: log(mass.a) ~ (Den + Gen)
Model 3: log(mass.a) ~ (Den + Gen + Den * Gen)
  Res.Df    RSS Df Sum of Sq      F Pr(>F)
1    213 668.41                           
2    212 662.87  1    5.5339 1.7800 0.1836
3    210 652.87  2   10.0093 1.6098 0.2024
> 
> summary(f.lm)

Call:
lm(formula = log(mass.a) ~ (Den), data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-3.5864 -1.4014  0.1614  1.3778  3.3957 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   1.2839     0.2088   6.150 3.78e-09 ***
DenL         -1.0499     0.2952  -3.556 0.000464 ***
DenM         -0.1893     0.2952  -0.641 0.521995    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.771 on 213 degrees of freedom
Multiple R-squared:  0.0632,	Adjusted R-squared:  0.0544 
F-statistic: 7.184 on 2 and 213 DF,  p-value: 0.0009563

> summary(f.lm2)

Call:
lm(formula = log(mass.a) ~ (Den + Gen), data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-3.7465 -1.3199  0.2282  1.4551  3.3212 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   1.4439     0.2406   6.001  8.4e-09 ***
DenL         -1.0499     0.2947  -3.563 0.000454 ***
DenM         -0.1893     0.2947  -0.642 0.521248    
GenLG        -0.3201     0.2406  -1.330 0.184831    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.768 on 212 degrees of freedom
Multiple R-squared:  0.07095,	Adjusted R-squared:  0.05781 
F-statistic: 5.397 on 3 and 212 DF,  p-value: 0.001345

> summary(f.lm3)

Call:
lm(formula = log(mass.a) ~ (Den + Gen + Den * Gen), data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-4.0503 -1.3634  0.1512  1.3541  3.6250 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   1.7477     0.2939   5.947 1.12e-08 ***
DenL         -1.5223     0.4156  -3.663 0.000316 ***
DenM         -0.6285     0.4156  -1.512 0.131985    
GenLG        -0.9278     0.4156  -2.232 0.026643 *  
DenL:GenLG    0.9447     0.5877   1.607 0.109467    
DenM:GenLG    0.8782     0.5877   1.494 0.136612    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.763 on 210 degrees of freedom
Multiple R-squared:  0.08498,	Adjusted R-squared:  0.06319 
F-statistic: 3.901 on 5 and 210 DF,  p-value: 0.00211

> 
> vec<- c("Gen")
> 
> emmeans(f.lm2, "Den", type='response', by=vec)
Gen = HG:
 Den response    SE  df lower.CL upper.CL
 H       4.24 1.020 212    2.637     6.81
 L       1.48 0.357 212    0.923     2.38
 M       3.51 0.844 212    2.182     5.63

Gen = LG:
 Den response    SE  df lower.CL upper.CL
 H       3.08 0.740 212    1.915     4.94
 L       1.08 0.259 212    0.670     1.73
 M       2.55 0.613 212    1.584     4.09

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> pairs(emmeans(f.lm2, "Den", type='response', by=vec))
Gen = HG:
 contrast ratio    SE  df t.ratio p.value
 H / L    2.857 0.842 212  3.563  0.0013 
 H / M    1.208 0.356 212  0.642  0.7968 
 L / M    0.423 0.125 212 -2.920  0.0108 

Gen = LG:
 contrast ratio    SE  df t.ratio p.value
 H / L    2.857 0.842 212  3.563  0.0013 
 H / M    1.208 0.356 212  0.642  0.7968 
 L / M    0.423 0.125 212 -2.920  0.0108 

P value adjustment: tukey method for comparing a family of 3 estimates 
Tests are performed on the log scale 
> 
> 
> #below ground biomass
> 
> b.lm<- lm(log(mass.b) ~ (Den) , data=fin)
> 
> b.lm2<- lm(log(mass.b) ~ (Den + Gen) , data=fin)
> 
> b.lm3<- lm(log(mass.b) ~ (Den + Gen + Den*Gen) , data=fin)
> 
> anova(b.lm, b.lm2, b.lm3)
Analysis of Variance Table

Model 1: log(mass.b) ~ (Den)
Model 2: log(mass.b) ~ (Den + Gen)
Model 3: log(mass.b) ~ (Den + Gen + Den * Gen)
  Res.Df    RSS Df Sum of Sq      F Pr(>F)
1    213 1161.9                           
2    212 1158.6  1    3.2495 0.5934  0.442
3    210 1149.9  2    8.7299 0.7972  0.452
> 
> summary(b.lm)

Call:
lm(formula = log(mass.b) ~ (Den), data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.3845 -1.3271  0.3035  1.7639  4.7921 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  -0.5232     0.2752  -1.901   0.0586 .  
DenL         -2.0828     0.3893  -5.351 2.26e-07 ***
DenM         -0.4522     0.3893  -1.162   0.2466    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 2.336 on 213 degrees of freedom
Multiple R-squared:  0.1295,	Adjusted R-squared:  0.1213 
F-statistic: 15.84 on 2 and 213 DF,  p-value: 3.852e-07

> summary(b.lm2)

Call:
lm(formula = log(mass.b) ~ (Den + Gen), data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.5072 -1.4498  0.4244  1.7945  4.9148 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  -0.4006     0.3181  -1.259    0.209    
DenL         -2.0828     0.3896  -5.346 2.32e-07 ***
DenM         -0.4522     0.3896  -1.161    0.247    
GenLG        -0.2453     0.3181  -0.771    0.442    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 2.338 on 212 degrees of freedom
Multiple R-squared:  0.1319,	Adjusted R-squared:  0.1196 
F-statistic: 10.74 on 3 and 212 DF,  p-value: 1.338e-06

> summary(b.lm3)

Call:
lm(formula = log(mass.b) ~ (Den + Gen + Den * Gen), data = fin)

Residuals:
   Min     1Q Median     3Q    Max 
-6.404 -1.383  0.520  1.700  5.196 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)   
(Intercept) -0.50357    0.39000  -1.291  0.19805   
DenL        -1.69884    0.55154  -3.080  0.00235 **
DenM        -0.52726    0.55154  -0.956  0.34019   
GenLG       -0.03935    0.55154  -0.071  0.94319   
DenL:GenLG  -0.76794    0.78000  -0.985  0.32598   
DenM:GenLG   0.15007    0.78000   0.192  0.84762   
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 2.34 on 210 degrees of freedom
Multiple R-squared:  0.1385,	Adjusted R-squared:  0.118 
F-statistic:  6.75 on 5 and 210 DF,  p-value: 7.395e-06

> 
> emmeans(b.lm2, "Den", type='response', by=vec)
Gen = HG:
 Den response     SE  df lower.CL upper.CL
 H     0.6699 0.2131 212   0.3578    1.254
 L     0.0835 0.0266 212   0.0446    0.156
 M     0.4262 0.1356 212   0.2277    0.798

Gen = LG:
 Den response     SE  df lower.CL upper.CL
 H     0.5242 0.1668 212   0.2800    0.981
 L     0.0653 0.0208 212   0.0349    0.122
 M     0.3335 0.1061 212   0.1781    0.624

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> 
> pairs(emmeans(b.lm2, "Den", type='response', by=vec))
Gen = HG:
 contrast ratio     SE  df t.ratio p.value
 H / L    8.027 3.1275 212  5.346  <.0001 
 H / M    1.572 0.6124 212  1.161  0.4780 
 L / M    0.196 0.0763 212 -4.185  0.0001 

Gen = LG:
 contrast ratio     SE  df t.ratio p.value
 H / L    8.027 3.1275 212  5.346  <.0001 
 H / M    1.572 0.6124 212  1.161  0.4780 
 L / M    0.196 0.0763 212 -4.185  0.0001 

P value adjustment: tukey method for comparing a family of 3 estimates 
Tests are performed on the log scale 
> 
> 
> 
> #Below ground biomass
> 
> b.lm<- glm(mass.b ~ Den + Gen, data=fin)
> summary(b.lm)

Call:
glm(formula = mass.b ~ Den + Gen, data = fin)

Deviance Residuals: 
    Min       1Q   Median       3Q      Max  
-1.5291  -1.1279  -0.6962   0.3388   8.1377  

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  1.53009    0.23333   6.558  4.1e-10 ***
DenL        -0.72596    0.28577  -2.540   0.0118 *  
DenM        -0.01676    0.28577  -0.059   0.9533    
GenLG       -0.04182    0.23333  -0.179   0.8579    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for gaussian family taken to be 2.939839)

    Null deviance: 648.07  on 215  degrees of freedom
Residual deviance: 623.25  on 212  degrees of freedom
AIC: 851.87

Number of Fisher Scoring iterations: 2

> 
> ref_grid(b.lm)
'emmGrid' object with variables:
    Den = H, L, M
    Gen = HG, LG
> emmeans(b.lm, "Den", "Gen", type='response')
Gen = HG:
 Den emmean    SE  df asymp.LCL asymp.UCL
 H    1.530 0.233 Inf     1.073      1.99
 L    0.804 0.233 Inf     0.347      1.26
 M    1.513 0.233 Inf     1.056      1.97

Gen = LG:
 Den emmean    SE  df asymp.LCL asymp.UCL
 H    1.488 0.233 Inf     1.031      1.95
 L    0.762 0.233 Inf     0.305      1.22
 M    1.472 0.233 Inf     1.014      1.93

Confidence level used: 0.95 
> 
> #plot(emmeans(b.lm, "Den", "Gen", type='response'))
> 
> 
> pairs(emmeans(b.lm, "Den", "Gen", type='response'))
Gen = HG:
 contrast estimate    SE  df z.ratio p.value
 H - L      0.7260 0.286 Inf  2.540  0.0298 
 H - M      0.0168 0.286 Inf  0.059  0.9981 
 L - M     -0.7092 0.286 Inf -2.482  0.0349 

Gen = LG:
 contrast estimate    SE  df z.ratio p.value
 H - L      0.7260 0.286 Inf  2.540  0.0298 
 H - M      0.0168 0.286 Inf  0.059  0.9981 
 L - M     -0.7092 0.286 Inf -2.482  0.0349 

P value adjustment: tukey method for comparing a family of 3 estimates 
> test(emmeans(b.lm, "Den", "Gen", type='response'))
Gen = HG:
 Den emmean    SE  df z.ratio p.value
 H    1.530 0.233 Inf 6.558   <.0001 
 L    0.804 0.233 Inf 3.446   0.0006 
 M    1.513 0.233 Inf 6.486   <.0001 

Gen = LG:
 Den emmean    SE  df z.ratio p.value
 H    1.488 0.233 Inf 6.378   <.0001 
 L    0.762 0.233 Inf 3.267   0.0011 
 M    1.472 0.233 Inf 6.307   <.0001 

> 
> ######################################################################################
> #Analysis of aborted embryos
> ######################################################################################
> 
> #Load data
> fin<- read.csv("C:/Users/Mason Kulbaba/Dropbox/git/density-Ne/data/aster.dat.csv")
> 
> #change class of factor variables
> fin$Den<- as.factor(fin$Den)
> fin$Gen<- as.factor(fin$Gen)
> fin$plotID<- as.factor(fin$plotID)
> fin$plantID<- as.factor(fin$plantID)
> fin$familyID<- as.factor(fin$familyID)
> 
> #################################################################
> #aboted embryo analysis with linear models
> 
> 
> lm1<- lm(log(aborted +1) ~ Den , data=fin)
> 
> lm2<- lm(log(aborted +1) ~ Den + Gen, data=fin)
> 
> lm3<- lm(log(aborted +1) ~ Gen + Den + Den*Gen, data=fin)#interaction not significant       
> 
> anova(lm1, lm2, lm3)
Analysis of Variance Table

Model 1: log(aborted + 1) ~ Den
Model 2: log(aborted + 1) ~ Den + Gen
Model 3: log(aborted + 1) ~ Gen + Den + Den * Gen
  Res.Df    RSS Df Sum of Sq      F Pr(>F)
1    213 392.06                           
2    212 391.27  1   0.79321 0.4275 0.5139
3    210 389.61  2   1.65923 0.4472 0.6400
> 
> summary(lm1)

Call:
lm(formula = log(aborted + 1) ~ Den, data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-3.4257 -0.5497  0.2370  1.0091  2.4230 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   3.4257     0.1599  21.426  < 2e-16 ***
DenL         -1.3601     0.2261  -6.015 7.74e-09 ***
DenM         -0.6282     0.2261  -2.778  0.00596 ** 
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.357 on 213 degrees of freedom
Multiple R-squared:  0.1454,	Adjusted R-squared:  0.1374 
F-statistic: 18.13 on 2 and 213 DF,  p-value: 5.377e-08

> summary(lm2)

Call:
lm(formula = log(aborted + 1) ~ Den + Gen, data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-3.4863 -0.5556  0.1837  0.9946  2.3870 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   3.3651     0.1849  18.203  < 2e-16 ***
DenL         -1.3601     0.2264  -6.007 8.12e-09 ***
DenM         -0.6282     0.2264  -2.774  0.00603 ** 
GenLG         0.1212     0.1849   0.656  0.51280    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.359 on 212 degrees of freedom
Multiple R-squared:  0.1472,	Adjusted R-squared:  0.1351 
F-statistic: 12.19 on 3 and 212 DF,  p-value: 2.154e-07

> summary(lm3)

Call:
lm(formula = log(aborted + 1) ~ Gen + Den + Den * Gen, data = fin)

Residuals:
    Min      1Q  Median      3Q     Max 
-3.4981 -0.5671  0.1754  0.9508  2.2743 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   3.3534     0.2270  14.772  < 2e-16 ***
GenLG         0.1446     0.3210   0.451    0.653    
DenL         -1.4494     0.3210  -4.515 1.06e-05 ***
DenM         -0.5037     0.3210  -1.569    0.118    
GenLG:DenL    0.1785     0.4540   0.393    0.695    
GenLG:DenM   -0.2489     0.4540  -0.548    0.584    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.362 on 210 degrees of freedom
Multiple R-squared:  0.1508,	Adjusted R-squared:  0.1306 
F-statistic: 7.458 on 5 and 210 DF,  p-value: 1.838e-06

> 
> 
> emmeans(lm3, "Den", "Gen", type="response")
Gen = HG:
 Den response   SE  df lower.CL upper.CL
 H      28.60 6.49 210    18.28     44.7
 L       6.71 1.52 210     4.29     10.5
 M      17.28 3.92 210    11.05     27.0

Gen = LG:
 Den response   SE  df lower.CL upper.CL
 H      33.05 7.50 210    21.13     51.7
 L       9.27 2.11 210     5.93     14.5
 M      15.57 3.53 210     9.95     24.4

Confidence level used: 0.95 
Intervals are back-transformed from the log scale 
> #plot(emmeans(lm3, "Den", "Gen", type="response"))
> pairs(emmeans(lm3, "Den","Gen", type="response"))
Gen = HG:
 contrast ratio    SE  df t.ratio p.value
 H / L    4.260 1.368 210  4.515  <.0001 
 H / M    1.655 0.531 210  1.569  0.2614 
 L / M    0.388 0.125 210 -2.946  0.0100 

Gen = LG:
 contrast ratio    SE  df t.ratio p.value
 H / L    3.564 1.144 210  3.958  0.0003 
 H / M    2.123 0.681 210  2.344  0.0520 
 L / M    0.596 0.191 210 -1.614  0.2419 

P value adjustment: tukey method for comparing a family of 3 estimates 
Tests are performed on the log scale 
> test(emmeans(lm3, "Den","Gen", type="response"))
Gen = HG:
 Den response   SE  df t.ratio p.value
 H      28.60 6.49 210 14.772  <.0001 
 L       6.71 1.52 210  8.387  <.0001 
 M      17.28 3.92 210 12.553  <.0001 

Gen = LG:
 Den response   SE  df t.ratio p.value
 H      33.05 7.50 210 15.409  <.0001 
 L       9.27 2.11 210  9.811  <.0001 
 M      15.57 3.53 210 12.094  <.0001 

Tests are performed on the log scale 
> 
> 
> proc.time()
   user  system elapsed 
   4.17    0.68    4.96 
